\chapter{OpenCAL OpenCL version}\label{ch:opencal-cl}


This chapter introduces OpenCAL-CL, a porting of OpenCAL in
OpenCL. OpenCL is a parallel framework, originally proposed by Apple
and then released as an Open Standard under the Khronos Group
management. Besides computational efficiency, one of the main
advantages of OpenCL is portability. In fact, it allows to run
programs across heterogeneous processors, like Central Processing Units
(CPUs), Graphics Processing Units (GPUs), Digital Signal Processors
(DSPs), and Field-Programmable Gate Arrays (FPGAs).

OpenCAL-CL inherits many OpenCAL's features, by also adding parallel
computation capability thanks to the adoption of OpenCL. OpenCAL-CL
based applications are subdivided in two parts: the \emph{host
  program}, running on the CPU, and the \emph{device program}, running
on a compliant computational device (e.g. a Nvidia or AMD GPU). The CA
object is still defined host-side, as in OpenCAL and OpenCAL-OMP,
while elementary processes (and possibly other functions) are defined
device-side, due to their \textsl{parallel nature} in the CA
context. Accordingly, elementary processes must be defined as OpenCL
\emph{kernels} and therefore developers have to be able to write some
minimal OpenCL code to implement them. Fortunately, OpenCAL-CL hides
lots of parallel aspects to the user (e.g., the simulation loop is
internally managed by the library) and also simplifies data exchange
between host and device. Therefore, OpenCL parallel programming
background can be limited or even null. In any case, the user can
learn some basic elements of OpenCL kernel programming thanks to this
guide.

This chapter is divided in two parts: the first part is a very brief
overview to OpenCL, while the second one introduces OpenCAL-CL by
examples.

\section{OpenCAL-CL structure}\label{sec:opencalclstructure}
In the OpenCAL-CL modeling context, host application, runing on the
CPU, defines the CA model and also performs data exchange and kernels
(i.e. elementary processes) execution on the compliant device. Data
exchange and kernels execution are managed thanks to an OpenCL
\emph{context}. In particular, the host application links kernels into
one or more containers, called \emph{programs}. The program therefore
connects kernels with the data to be processed and dispatches them to
a special OpenCL structure called \emph{command queue}. This is
necessary because only enqueued kernel are actually executed. Figure
\ref{fig:GeneralStructure} shows the general structure of an OpenCL
program. Context contains all the devices, command queues and kernels,
each device has its own command queue and each command queue contains
the kernels to be executed on the corresponding device.

\begin{figure}[htp]
  \begin{center}
    \includegraphics[width=12cm]{./images/OpenCAL-CL/kernelDistribution}
    \caption{General structure of a OpenCL program, from \emph{OpenCL
        in Action: How to accelerate graphics and computations},
      Matthew Scarpino, Manning Pubblication, ISBN-13:
      860-1400825129.}
    \label{fig:GeneralStructure}
  \end{center}
\end{figure}

Specifically, an OpenCAL-CL host application is typically
subdivided in the following parts:
\begin{itemize}
\item Definition of the CA model;
\item Management of the OpenCL devices;
\item Kernels definition and allocation;
\item Data dispatch from the CA model, defined host-side, to the compliant OpenCL device;
\item Start of the CA simulation main loop (kernel execution).
\end{itemize}

OpenCAL-CL CA definition does not differ from what done for the cases
of OpenCAL (cf. Chapter \ref{ch:opencal}) and OpenCAL-OMP (cf. Chapter
\ref{ch:opencal-omp}). At the contrary, compliant device management,
kernel definition and allocation, data dispatch, and kernel execution
are completely new. All theese phases are discussed in the following
sections.

\subsection{Compliant Device Management}

After model definition, the user must select an OpenCL compliant
device in order to run the kernels. At this purpose, OpenCAL-CL
provides the \verb'CALOpenCL' structure that, together with other
utility functions, considerably simplifies platform, device, and
context management with respect to the native OpenCL API. Listing
\ref{lst:CALOpenCL} shows how to select a compliant device in
OpenCAL-CL.

\begin{lstlisting}[float,floatplacement=H, label=lst:CALOpenCL, caption=Access to platform and devices.]
  #include <calCL2D.h>

  int main ()
  {
    // Initilize a pointer to the calclCreateCALOpenCL structure
    CALOpenCL * calOpenCL = calclCreateCALOpenCL ();

    // get all available devices
    calclInitializePlatforms ( calOpenCL );

    // Initialize the devices
    calclInitializeDevices ( calOpenCL );

    // get the first device on the first platform
    CALCLdevice device = calclGetDevice ( calOpenCL , 0, 0 );

    // create a context
    CALCLcontext context = calclcreateContext ( &device , 1 );

    return 0;
  }
\end{lstlisting}

% which fills the object with the platforms available on the machine.

The \verb'calCL2D.h' header file, needed to define OpenCAL-CL 2D CA,
is included at line 1. Line 6 declares a pointer to the above cited
\verb'CALOpenCL' strucure, and initializes it throgh the
\verb'calclCreateCALOpenCL()' utility function. This object,
\verb'calOpenCL', is used as parameter for the
\verb'calclInitializePlatforms()' function at line 9, which fills the
object with the platforms available on the machine. Line 12 calls the
\verb'calclInitializeDevices()' function, that initializes the
available devices, while line 15 selects one of them for kernel
execution. Specifically, an object of type \verb'CALCLdevice' is
declared ad initialized by the function \verb'calclGetDevice()'. This
latter takes as first parameter a pointer to a \verb'CALOpenCL'
object, while the second and third parameters are used to select
platform and device, respectively. Since both platforms and devices
are identified by 0-based numerical ID, statement at line 15 selects
the first device belonging to the first platform (e.g. a GTX 980
belonging to the NVIDIA CUDA platform). Eventually, line 18 creates a
OpenCL context, based on the device previously selected. At this
porpose, an object of type \verb'CALCLcontext' declared and defined by
means of the \verb'calclcreateContext()' function.

In OpenCAL-CL platforms and devices are stored in a matrix where rows
represent platforms and columns devices. Thus, to choose which
platform and device to use for the computation, it is necessary to
specify their indexes within the matrix. For example, at lines 15, we
chose the platform number 0 and the device number 0. If we have a
system with 3 NVIDIA GPUs and 3 AMD GPUs, the library will have a $2
\times 3$ size matrix, where 2 are the vendors (i.e., the platforms
NVIDIA and AMD) and 3 are the GPUs for each platforms. If we want to
run the program using the third AMD GPU, we can specify 1 and 2 as
indices. If we don't know how the system identifies the platforms and
devices, the library supplies us a function called
\verb'calclGetPlatformsAndDeviceFromStandardInput' that allows us to
know the available platforms and devices. First it prints the
information on standard output and then we can insert the indices
directly from standard input.

After the device is chosen, the user must specify the path where the
kernels and relative headers are located (cf. Listing
\ref{lst:calclLoadProgramLib}). Through the function
\verb'calclLoadProgramLib(2D/3D)' the library automatically reads
kernels and compiles them.

\begin{lstlisting}[float,floatplacement=H, label=lst:calclLoadProgramLib, caption=The calclLoadProgramLib function., numbers=none]
  CALCLprogram calclLoadProgramLib(2D|3D) (
                  CALCLcontext context ,
                  CALCLdevice device ,
                  char * path_user_kernel ,
                  char * path_user_include
  )
\end{lstlisting}

\subsection{Kernels allocation}

The library doesn't know which kernels are related to the CA
elementary processes, nor their execution order on the available
devices. Thus, to create and allocate a kernel it Is necessary to call
the \verb'calclGetKernelFromProgram' function (see Listing
\ref{lst:calclGetKernelFromProgram}), that retrieves an OpenCL kernel
given a compiled OpenCL program.

\begin{lstlisting}[float,floatplacement=H, label=lst:calclGetKernelFromProgram, caption=The calclGetKernelFromProgram function., numbers=none]
  cl_kernel elementaryProcess = calclGetKernelFromProgram(
                                &program,
                                KERNEL_NAME);
\end{lstlisting}

\subsection{Sending data from the CA model to devices}

To transfer data from host side to kernel side, the user must define
the structure called \verb'CALCLToolkit(2D/3D)' containing all the
buffers (data) of the CA model. By default, the library sends to all
kernels the data associated to the model. Such data is listed
below:

\begin{itemize}
	\item the dimension of cellular space
	\item the number of substate for every type (i.e., byte, int, real)
	\item the substates allocated from the user
	\item the list of active cells
	\item the list of active cells flags
	\item type, dimension and ID of the neighbourhood
	\item the border condition
\end{itemize}

First, the user must create an instance of the structure
\verb'CALCLToolkit(2D/3D)' by calling the function
\verb'calclCreateToolkit' as shown in the following code snippet.

\begin{lstlisting}[numbers=none]
  CALCLToolkit2D * calclCreateToolkit (2D|3D)(
                   struct CALModel (2D|3D) *model,
                   CALCLcontext context,
                   CALCLprogram program,
                   CALCLdevice device,
                   CALCLOptimization opt
  )
\end{lstlisting}

The \verb'CALCLOptimization' enumerative allows the user to choose if
she/he wants to use the library without optimization
\verb|(CALCL_NO_OPT)| or with active cells optimization
\verb|(CALCL_OPT_ACTIVE_CELLS)|. The structure
\verb'CALCLToolkit(2D/3D)' doesn't contain only the buffers to
transfer data but also the kernels belonging to the execution
loop.

To add a new kernel to the execution loop, the user has to
call the function \verb'calclAddElementaryProcessKernel(2D/3D)' that
adds the chosen kernel to the list of CA elementary processes;
moreover, it sends to the device all the necessary data to execute the
kernel.

\begin{lstlisting}[numbers=none]
  void calclAddElementaryProcessKernel2D(
               CALCLToolkit2D * toolkit2d,
               struct CALModel2D *model,
               CALCLkernel * elemProcKernel
  );
\end{lstlisting}


\subsection{Start execution loop}

To start the execution loop, the user has to call the function
\verb'calclRun(2D/3D)'. This function executes all the elementary
processes previously declared on the specified device.

\begin{lstlisting}[numbers=none]
  void calclRun2D(CALCLToolkit2D* toolkit2d,
                  struct CALModel2D * model,
                  unsigned int initialStep,
                  unsigned maxStep
  );
\end{lstlisting}


\section{Kernel programming}

In order to program kernels in OpenCAL, the user needs to include some
header files. Specifically, \verb'cal2D.h' or \verb'cal3D.h' permit
to use some simple functions to interact with the data structures
belonging to the model. To create a kernel function in OpenCL, the user
must place the keyword \verb'__kernel' before the returning the type
of the function. In OpenCAL-CL every time a kernel function is defined, the
keyword \verb'MODEL_DEFINITION2D' must be specified as first parameter
and the function \verb'initThreads2D()' called as first
instruction.\\ The code below shows how to declare a new kernel.

\begin{lstlisting} 
  __kernel void kernel(MODEL_DEFINITION2D)
  {
    initThreads2D();
    //...
    //...
    //...
  }
\end{lstlisting}

When the user implements an elementary process - by defining
the corresponding kernel function - she/he can rely on a set of OpenCAL functions
that allow to get the substates values of both the central and the
neighbouring cells, and to update the substates values of the central
cell. Every time the user wants to use this function, the keyword \verb'MODEL2D' must be passed
as first parameter. For instance, if we
want to retrieve the value of a specific cell we need to use the function
\verb'calGet2Dr'.

\begin{lstlisting}[numbers=none] 
	double a = calGet2Dr(MODEL2D, 0, i, j);
\end{lstlisting}

The function returns the value of the cell (i, j) of the substate
0. Since inside OpenCAL-CL one can use all OpenCL advanced features, all
memory levels such as global memory, local memory, private memory
can be exploited. In order to use these memory
levels, variables must be declared using this specific syntax
\verb'__global', \verb'__local', \verb'__private',respectively.

\section{Conway's Game of Life with OpenCAL-CL}
 
As already reported in \ref{sec:cal_life}, to introduce how to develop
a CA model with OpenCAL-CL we can start by implementing Conway’s Game
of Life and specifically its host application part, which is shown in
Listing \ref{lst:calcl_life}. In order to use OpenCAL-CL, some header
files are included (lines 3-8) and, in particular, the OpenCAL library
and the OpenCAL-CL library. The OpenCAL library inclusion is necessary
to define the CA object (line 46) and the related substates (line
49). The \verb'cal2DIO.h' header file (line 4) provides some basic
input/output functions for reading/writing substates from/to file. To
run the application with OpenCAL-CL, all the necessary objects have to
be declared (line 27-31): specifically, the \verb'CALOpenCL' structure
(line 27), the \verb'CALCLcontext', the \verb'CALCLdevice', the
\verb'CALCLprogram' and the \verb'CALCLToolkit2D'. To create and
initialize these variables we need to call the function
\verb'calclCreateCALOpenCL' that creates the CALOpenCL structure, the
functions \verb|calclInitializePlatforms| and
\verb|calclInitializeDevices| that initialize all the platforms and
devices on the available machine and the \verb'calclGetDevice()'
function, which will return the device where elementary process are
computed by choosing the \verb'platformNum' and \verb'deviceNum'
integers(line 24-25). Moreover, two important functions are here
considered: \verb'calclcreateContext' and
\verb'calclLoadProgramLib2D'. The first returns the context
(see \ref{sec:opencalclstructure}), while the second builds all kernels inside
the path specified by \verb'kernelSrc'(line 15) including the files
specified by \verb'kernelInc'(line 16), and returns a program
containing all the compiled kernels.

The definition and declaration of the model (line 46) has the same code
that we discussed in \ref{sec:cal_life}, and includes all the information
to create the model, to create and initialize substates (line 49-52) and 
to set a initial configuration (line 55-59).

\lstinputlisting[label=lst:calcl_life, caption=An OpenCAL-CL
  implementation of the Conway's game of
  Life.]{../opencal/OpenCAL-CL/examples/calcl_life/source/life.c}
	
Although the OpenCAL-CL library uses the same functions of the OpenCAL
library to create the model and the substates, the execution of the
elementary processes is quite different. As known, our elementary
processes are implemented on GPU side through kernels, so we need to
manage the transfer of memory between host and device sides and to
decide which and when run the kernels. In a classical OpenCL
application, it's not trivial to handle all these issues. For this
reason, in OpenCAL-CL we decided to introduce an intermediate object
(\verb'CALCLToolkit') that hides to the user the memory management and
handles the compiled chosen kernels. The user must only initialize the
\verb'CALCLToolkit' structure(line 62) and choose which kernel he/she
wants to execute by the function \verb'calclGetKernelFromProgram'
specifying the program and kernel names. Once kernels are chosen to be
executed, the user must only call the function
\verb'calclAddElementaryProcessKernel2D' (line 71) that adds the
specific kernel elementary process inside the \verb'CALCLToolkit'
structure. Finally, to run the simulation, the user must call the
function \verb'calclRun2D' specifying the initial and final step.

Below is reported the device-side code of Conway's Game of Life.  In
this application, we have only one elementary process, defined as a
kernel called \verb'life_transition_function'. The OpenCAL-CL library
will launch exactly a number of threads equal to the entire cellular
space, structured like a matrix. In this way, every cell can perform
in parallel its own computation. To access to the indexes of the cell
the user must call the function \verb'getRow' and \verb'getCol'
line(14-15). Furthermore, the user can use the function
\verb'get_columns' and \verb'get_rows' (line 17-18) to retrieve the
dimensions of the cellular space.  In the specific case of the Game of
Life, we used the \verb'calGet2Di' function to get the central cell’s
value of the substate Q (remember that the central cell is identified
by the coordinates (i, j)), the \verb'calGetX2Di' function to retrieve
the value of the n-th neighbour’s substate Q, and the \verb'calSet2Di'
function to update the value of the substate Q for the central cell.

\lstinputlisting[label=lst:calcl_life, caption=An OpenCAL-CL kernel
  to implement the Conway's game of Life elementary
  process.]{../opencal/OpenCAL-CL/examples/calcl_life/kernel/source/life.cl}


\section{Combining OpenCAL-OMP and OpenCAL-GL and  Global Functions}

As for OpenCAL, it is possible to exploit OpenCAL-GL to have a simple
visualization system by adding few lines of code to your
application. Combining OpenCAL-CL and OpenCAL-GL does not differ from
what we have done in Section \ref{sec:combining_gl} for OpenCAL and
OpenCAL-GL. Therefore, please refer to this section for major
details.

Similarly, you can use the same global reduction functions
described in Section \ref{sec:redution} also in OpenCAL-CL.  Please
refer to that section for further details.
