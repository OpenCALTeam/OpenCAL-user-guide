\chapter{OpenCAL OpenCL version}\label{ch:opencal-cl}


This chapter introduces OpenCAL-CL, a porting of OpenCAL in
OpenCL. OpenCL is a parallel framework originally proposed by Apple
and then released as an Open Standard under the Khronos Group
management. Besides computational efficiency, one of the main
advantages of OpenCL is portability. In fact, you can run your program
wherever you want across heterogeneous processors like Central
Processing Units (CPUs), Graphics Processing Units (GPUs), Digital
Signal Processors (DSPs), and Field-Programmable Gate Arrays (FPGAs).

OpenCAL-CL inherits many OpenCAL's features, by also adding parallel
computation capability thanks to the adoption of OpenCL. The
application is now subdivided in two parts: the \emph{host program},
running on the CPU, and the \emph{device program}, running on a
compliant computational device (e.g. a Nvidia or AMD GPU). The CA
object is still defined host-side, as in OpenCAL, while elementary
processes (and possibly other functions), due to their \textsl{parallel nature} in the CA context, are defined
device-side. Moreover, belonging to the device program, CA elementary processes
must be defined as OpenCL's \emph{kernels} and therefore the developer
has to be able to write some minimal OpenCL code to implement
them. Fortunately, OpenCAL-CL hides lots of parallel aspects to the
user (e.g., the simulation loop is internally managed by the library)
and also simplifies data exchange between host and device. The user's
OpenCL parallel programming background can be therefore limited or
even null. However, the user can learn some basic elements
of OpenCL kernel programming thanks to this guide \footnote{For more in-depth knowledge of OpenCL, please refer to the book OpenCL in Action: How to accelerate graphics and computations, Matthew Scarpino, Manning Pubblication, ISBN-13: 860-1400825129.}.

This chapter is divided in two parts: the first part is a very brief
overview of OpenCL, while the second one introduces OpenCAL-CL by
examples.

\section{OpenCL framework}\label{sec:openclstructure}
As already stated, OpenCL allows for the parallel execution of
computational tasks, called kernels, on multiple processing elements
of compliant devices. In the OpenCAL-CL modeling context, the host
application, which runs on the CPU, defines the CA model and also
performs data exchange and kernels execution on the compliant device.
Data exchange and kernels execution are managed thanks to an OpenCL
\emph{context}. Each CA elementary process is implemented as a kernel
and is therefore sent to a compliant device for execution.

In particular, the host application links kernels into one or more
containers, called \emph{programs}.The program therefore connects
kernels with the data to be processed and dispatches them to a special
OpenCL structure called \emph{command queue}. This is a necessary
because only enqueued kernel are actually executed.

%The command queue is a structure that allows the host to decide what
%the devices have to do and, when a kernel is enqueued, the device
%will execute the relative function.

\begin{figure}[htp]
  \begin{center}
    \includegraphics[width=12cm]{./images/OpenCAL-CL/kernelDistribution}
    \caption{General structure of a OpenCL program}
    \label{fig:GeneralStructure}
  \end{center}
\end{figure}

Figure \ref{fig:GeneralStructure} shows the general structure of an
OpenCL program. Context contains all the devices, command queues
and kernels, each device has its own command queue and each
command queue contains the kernels to be executed on the corresponding
device.

\section{The structure of OpenCAL-CL}
OpenCAL-CL provides a set of predefined structures and functions to
develop CA oriented host applications and kernels. CA
objects\footnote{2D and 3D CA are natively supported by
  OpenCAL-CL. Also 1D CA can be defined as degenerate case of a 2D
  CA.} and substates are defined in the host application. Moreover,
this latter manages kernels and dispatches data to be processed (e.g.,
CA substates, the type of neighbourhood, size of the cellular space,
etc) to the computational compliant unit. The host application also
selects the computational unit to be employed and manages the
execution of the CA main loop. The host application is typically
subdivided in the following parts:
\begin{itemize}
\item Definition of the CA model\footnote{OpenCAL-CL CA definition
  does not differ from what done for the cases of OpenCAL (cf. Chapter
  \ref{ch:opencal}) and OpenCAL-OMP (cf. Chapter
  \ref{ch:opencal-omp}).};
\item Management of the OpenCL devices;
\item Kernels definition and allocation;
\item Data dispatch from the CA model, defined host-side, to the device;
\item Start of the CA simulation main loop.
\end{itemize}

\section{Host programming} 

\subsection{Definition of the CA model}

XXX

\subsection{Manage of the devices}

After model definition, the user must choose the device for kernel
execution. An OpenCAL-CL structure called \verb'CALOpenCL' allows the
user to manage all available platforms and devices. This structure
simplifies the access to the devices compared with the native API of
OpenCL. The library supplies other functions to know which platforms
and devices are available on the system and to have information about
these. Below you can see a simple program showing how the
\verb'CALOpenCL' structure can be used (Listing \ref{lst:CALOpenCL}).


\begin{lstlisting}[float,floatplacement=H, label=lst:CALOpenCL, caption=Access to platform and devices.]
  #include <calCL2D .h>

  int main ()
  {
    // get all available  platforms
    CALOpenCL * calOpenCL = calclCreateCALOpenCL ();
    // get all available devices
    calclInitializePlatforms ( calOpenCL );

    // Initialize the devices
    calclInitializeDevices ( calOpenCL );

    // get the first device on the first platform
    CALCLdevice device = calclGetDevice ( calOpenCL , 0, 0 );

    // create a context
    CALCLcontext context = calclcreateContext ( &device , 1 );

    return 0;
  }
\end{lstlisting}

In OpenCAL-CL platforms and devices are stored in a matrix where rows
represent platforms and columns devices. Thus, to choose which
platform and device to use for the computation, it is necessary to
specify their indexes within the matrix. For example, at lines 14, we
chose the platform number 0 and the device number 0. If we have a
system with 3 NVIDIA GPUs and 3 AMD GPUs, the library will have a $2
\times 3$ size matrix, where 2 are the vendors (i.e., the platforms
NVIDIA and AMD) and 3 are the GPUs for each platforms. If we want to
run the program using the third AMD GPU, we can specify 1 and 2 as
indices. If we don't know how the system identifies the platforms and
devices, the library supplies us a function called
\verb'calclGetPlatformsAndDeviceFromStandardInput' that allows us to
know the available platforms and devices. First it prints the
information on standard output and then we can insert the indices
directly from standard input.

After the device is chosen, the user must specify the path where the
kernels and relative headers are located (cf. Listing
\ref{lst:calclLoadProgramLib}). Through the function
\verb'calclLoadProgramLib(2D/3D)' the library automatically reads
kernels and compiles them.

\begin{lstlisting}[float,floatplacement=H, label=lst:calclLoadProgramLib, caption=The calclLoadProgramLib function., numbers=none]
  CALCLprogram calclLoadProgramLib(2D|3D) (
                  CALCLcontext context ,
                  CALCLdevice device ,
                  char * path_user_kernel ,
                  char * path_user_include
  )
\end{lstlisting}

\subsection{Kernels allocation}

The library doesn't know which kernels are related to the CA
elementary processes, nor their execution order on the available
devices. Thus, to create and allocate a kernel it Is necessary to call
the \verb'calclGetKernelFromProgram' function (see Listing
\ref{lst:calclGetKernelFromProgram}), that retrieves an OpenCL kernel
given a compiled OpenCL program.

\begin{lstlisting}[float,floatplacement=H, label=lst:calclGetKernelFromProgram, caption=The calclGetKernelFromProgram function., numbers=none]
  cl_kernel elementaryProcess = calclGetKernelFromProgram(
                                &program,
                                KERNEL_NAME);
\end{lstlisting}

\subsection{Sending data from the CA model to devices}

To transfer data from host side to kernel side, the user must define
the structure called \verb'CALCLToolkit(2D/3D)' containing all the
buffers (data) of the CA model. By default, the library sends to all
kernels the data associated to the model. Such data is listed
below:

\begin{itemize}
	\item the dimension of cellular space
	\item the number of substate for every type (i.e., byte, int, real)
	\item the substates allocated from the user
	\item the list of active cells
	\item the list of active cells flags
	\item type, dimension and ID of the neighbourhood
	\item the border condition
\end{itemize}

First, the user must create an instance of the structure
\verb'CALCLToolkit(2D/3D)' by calling the function
\verb'calclCreateToolkit' as shown in the following code snippet.

\begin{lstlisting}[numbers=none]
  CALCLToolkit2D * calclCreateToolkit (2D|3D)(
                   struct CALModel (2D|3D) *model,
                   CALCLcontext context,
                   CALCLprogram program,
                   CALCLdevice device,
                   CALCLOptimization opt
  )
\end{lstlisting}

The \verb'CALCLOptimization' enumerative allows the user to choose if
she/he wants to use the library without optimization
\verb|(CALCL_NO_OPT)| or with active cells optimization
\verb|(CALCL_OPT_ACTIVE_CELLS)|. The structure
\verb'CALCLToolkit(2D/3D)' doesn't contain only the buffers to
transfer data but also the kernels belonging to the execution
loop.

To add a new kernel to the execution loop, the user has to
call the function \verb'calclAddElementaryProcessKernel(2D/3D)' that
adds the chosen kernel to the list of CA elementary processes;
moreover, it sends to the device all the necessary data to execute the
kernel.

\begin{lstlisting}[numbers=none]
  void calclAddElementaryProcessKernel2D(
               CALCLToolkit2D * toolkit2d,
               struct CALModel2D *model,
               CALCLkernel * elemProcKernel
  );
\end{lstlisting}


\subsection{Start execution loop}

To start the execution loop, the user has to call the function
\verb'calclRun(2D/3D)'. This function executes all the elementary
processes previously declared on the specified device.

\begin{lstlisting}[numbers=none]
  void calclRun2D(CALCLToolkit2D* toolkit2d,
                  struct CALModel2D * model,
                  unsigned int initialStep,
                  unsigned maxStep
  );
\end{lstlisting}


\section{Kernel programming}

In order to program kernels in OpenCAL, the user needs to include some
header files. Specifically, \verb'cal2D.h' or \verb'cal3D.h' permit
to use some simple functions to interact with the data structures
belonging to the model. To create a kernel function in OpenCL, the user
must place the keyword \verb'__kernel' before the returning the type
of the function. In OpenCAL-CL every time a kernel function is defined, the
keyword \verb'MODEL_DEFINITION2D' must be specified as first parameter
and the function \verb'initThreads2D()' called as first
instruction.\\ The code below shows how to declare a new kernel.

\begin{lstlisting} 
  __kernel void kernel(MODEL_DEFINITION2D)
  {
    initThreads2D();
    //...
    //...
    //...
  }
\end{lstlisting}

When the user implements an elementary process - by defining
the corresponding kernel function - she/he can rely on a set of OpenCAL functions
that allow to get the substates values of both the central and the
neighbouring cells, and to update the substates values of the central
cell. Every time the user wants to use this function, the keyword \verb'MODEL2D' must be passed
as first parameter. For instance, if we
want to retrieve the value of a specific cell we need to use the function
\verb'calGet2Dr'.

\begin{lstlisting}[numbers=none] 
	double a = calGet2Dr(MODEL2D, 0, i, j);
\end{lstlisting}

The function returns the value of the cell (i, j) of the substate
0. Since inside OpenCAL-CL one can use all OpenCL advanced features, all
memory levels such as global memory, local memory, private memory
can be exploited. In order to use these memory
levels, variables must be declared using this specific syntax
\verb'__global', \verb'__local', \verb'__private',respectively.

\section{Conway's Game of Life with OpenCAL-CL}
 
As already reported in \ref{sec:cal_life}, to introduce how to develop
a CA model with OpenCAL-CL we can start by implementing Conway’s Game
of Life and specifically its host application part, which is shown in
Listing \ref{lst:calcl_life}. In order to use OpenCAL-CL, some header
files are included (lines 3-8) and, in particular, the OpenCAL library
and the OpenCAL-CL library. The OpenCAL library inclusion is necessary
to define the CA object (line 46) and the related substates (line
49). The \verb'cal2DIO.h' header file (line 4) provides some basic
input/output functions for reading/writing substates from/to file. To
run the application with OpenCAL-CL, all the necessary objects have to
be declared (line 27-31): specifically, the \verb'CALOpenCL' structure
(line 27), the \verb'CALCLcontext', the \verb'CALCLdevice', the
\verb'CALCLprogram' and the \verb'CALCLToolkit2D'. To create and
initialize these variables we need to call the function
\verb'calclCreateCALOpenCL' that creates the CALOpenCL structure, the
functions \verb|calclInitializePlatforms| and
\verb|calclInitializeDevices| that initialize all the platforms and
devices on the available machine and the \verb'calclGetDevice()'
function, which will return the device where elementary process are
computed by choosing the \verb'platformNum' and \verb'deviceNum'
integers(line 24-25). Moreover, two important functions are here
considered: \verb'calclcreateContext' and
\verb'calclLoadProgramLib2D'. The first returns the context
\ref{sec:openclstructure}, while the second builds all kernels inside
the path specified by \verb'kernelSrc'(line 15) including the files
specified by \verb'kernelInc'(line 16), and returns a program
containing all the compiled kernels.

The definition and declaration of the model (line 46) has the same code
that we discussed in \ref{sec:cal_life}, and includes all the information
to create the model, to create and initialize substates (line 49-52) and 
to set a initial configuration (line 55-59).

\lstinputlisting[label=lst:calcl_life, caption=An OpenCAL-CL
  implementation of the Conway's game of
  Life.]{../opencal/OpenCAL-CL/examples/calcl_life/source/life.c}
	
Although the OpenCAL-CL library uses the same functions of the OpenCAL
library to create the model and the substates, the execution of the
elementary processes is quite different. As known, our elementary
processes are implemented on GPU side through kernels, so we need to
manage the transfer of memory between host and device sides and to
decide which and when run the kernels. In a classical OpenCL
application, it's not trivial to handle all these issues. For this
reason, in OpenCAL-CL we decided to introduce an intermediate object
(\verb'CALCLToolkit') that hides to the user the memory management and
handles the compiled chosen kernels. The user must only initialize the
\verb'CALCLToolkit' structure(line 62) and choose which kernel he/she
wants to execute by the function \verb'calclGetKernelFromProgram'
specifying the program and kernel names. Once kernels are chosen to be
executed, the user must only call the function
\verb'calclAddElementaryProcessKernel2D' (line 71) that adds the
specific kernel elementary process inside the \verb'CALCLToolkit'
structure. Finally, to run the simulation, the user must call the
function \verb'calclRun2D' specifying the initial and final step.

Below is reported the device-side code of Conway's Game of Life.  In
this application, we have only one elementary process, defined as a
kernel called \verb'life_transition_function'. The OpenCAL-CL library
will launch exactly a number of threads equal to the entire cellular
space, structured like a matrix. In this way, every cell can perform
in parallel its own computation. To access to the indexes of the cell
the user must call the function \verb'getRow' and \verb'getCol'
line(14-15). Furthermore, the user can use the function
\verb'get_columns' and \verb'get_rows' (line 17-18) to retrieve the
dimensions of the cellular space.  In the specific case of the Game of
Life, we used the \verb'calGet2Di' function to get the central cell’s
value of the substate Q (remember that the central cell is identified
by the coordinates (i, j)), the \verb'calGetX2Di' function to retrieve
the value of the n-th neighbour’s substate Q, and the \verb'calSet2Di'
function to update the value of the substate Q for the central cell.

\lstinputlisting[label=lst:calcl_life, caption=An OpenCAL-CL kernel
  to implement the Conway's game of Life elementary
  process.]{../opencal/OpenCAL-CL/examples/calcl_life/kernel/source/life.cl}


\section{Combining OpenCAL-OMP and OpenCAL-GL and  Global Functions}

As for OpenCAL, it is possible to exploit OpenCAL-GL to have a simple
visualization system by adding few lines of code to your
application. Combining OpenCAL-CL and OpenCAL-GL does not differ from
what we have done in Section \ref{sec:combining_gl} for OpenCAL and
OpenCAL-GL. Therefore, please refer to this section for major
details.

Similarly, you can use the same global reduction functions
described in Section \ref{sec:redution} also in OpenCAL-CL.  Please
refer to that section for further details.
