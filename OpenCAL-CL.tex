\chapter{OpenCAL OpenCL version}\label{ch:opencal-cl}


This chapter introduces OpenCAL-CL, a porting of OpenCAL in
OpenCL. OpenCL is a parallel framework, originally proposed by Apple
and then released as an Open Standard under the Khronos Group
management. Besides computational efficiency, one of the main
advantages of OpenCL is portability. In fact, it allows to run
programs across heterogeneous processors, like Central Processing Units
(CPUs), Graphics Processing Units (GPUs), Digital Signal Processors
(DSPs), and Field-Programmable Gate Arrays (FPGAs).

OpenCAL-CL inherits many OpenCAL's features, by also adding parallel
computation capability thanks to the adoption of OpenCL. OpenCAL-CL
based applications are subdivided in two parts: the \emph{host
  program}, running on the CPU, and the \emph{device program}, running
on a compliant computational device (e.g. a Nvidia or AMD GPU). The CA
object is still defined host-side, as in OpenCAL and OpenCAL-OMP,
while elementary processes (and possibly other functions) are defined
device-side, due to their \textsl{parallel nature} in the CA
context. Accordingly, elementary processes must be defined as OpenCL
\emph{kernels} and therefore developers have to be able to write some
minimal OpenCL code to implement them. Fortunately, OpenCAL-CL hides
lots of parallel aspects to the user (e.g., the simulation loop is
internally managed by the library) and also simplifies data exchange
between host and device. Therefore, OpenCL parallel programming
background can be limited or even null. In any case, the user can
learn some basic elements of OpenCL kernel programming thanks to this
guide.

This chapter is divided in two parts: the first part is a very brief
overview to OpenCL, while the second one introduces OpenCAL-CL by
examples.

\section{OpenCAL-CL structure}\label{sec:opencalclstructure}
In the OpenCAL-CL modeling context, the host application, runing on
the CPU, defines the CA model and also performs data exchange and
kernels (i.e. elementary processes) execution on the compliant device.

The CA model is defined exactly as in the case of the serial
implementation of OpenCAL (cf. Chapter \ref{ch:opencal}. However,
elementary processes are implemented as OpenCL kernels, to be executed
in parallel on compliant device. For this reason, they are not added
to the host-side CA model, but to the so called OpenCAL-CL \emph{toolkit},
which is also responsible for data exchange between host and device.

In order to better understand how OpenCAL-CL manages kernel execution
and data exchange, it is necessary to introduce some OpenCL
conceptss. Data exchange and kernels execution are managed thanks to
an OpenCL \emph{context}. In particular, the host application links
kernels into one or more containers, called \emph{programs}. The
program therefore connects kernels with the data to be processed and
dispatches them to a special OpenCL structure called \emph{command
  queue}. This is necessary because only enqueued kernel are actually
executed. Figure \ref{fig:GeneralStructure} shows the general
structure of an OpenCL program. Context contains all the devices,
command queues and kernels, each device has its own command queue and
each command queue contains the kernels to be executed on the
corresponding device.

\begin{figure}[htp]
  \begin{center}
    \includegraphics[width=12cm]{./images/OpenCAL-CL/kernelDistribution}
    \caption{General structure of a OpenCL program, from \emph{OpenCL
        in Action: How to accelerate graphics and computations},
      Matthew Scarpino, Manning Pubblication, ISBN-13:
      860-1400825129.}
    \label{fig:GeneralStructure}
  \end{center}
\end{figure}

Specifically, an OpenCAL-CL host application is typically
subdivided in the following parts:
\begin{itemize}
\item Definition of the host-side CA model;
\item Selection of the OpenCL compliant device;
\item OpenCAL-CL toolkit definition;
\item Kernels reading, compilation and enqueuing;
%\item Optional kernel parameters settings;
\item Simulation execution on the compliant device.
\end{itemize}

OpenCAL-CL CA definition does not differ from what done for the cases
of OpenCAL (cf. Chapter \ref{ch:opencal}) and OpenCAL-OMP (cf. Chapter
\ref{ch:opencal-omp}). At the contrary, compliant device management,
kernel definition and allocation, data dispatch, and kernel execution
are completely new. All theese phases are discussed in the following
sections.

\subsection{Selection of the OpenCL compliant device}

After model definition, the user must select an OpenCL compliant
device in order to run the kernels. At this purpose, OpenCAL-CL
provides the \verb'CALOpenCL' structure that, together with other
utility functions, considerably simplifies platform, device, and
context management with respect to the native OpenCL API. Listing
\ref{lst:CALOpenCL} shows how to select a compliant device in
OpenCAL-CL.

\begin{lstlisting}[float,floatplacement=H, label=lst:CALOpenCL, caption=Access to platform and devices.]
  #include <calCL2D.h>

  int main ()
  {
    // Initilize a pointer to the calclCreateCALOpenCL structure
    CALOpenCL * calclManager = calclCreateCALOpenCL ();

    // get all available platforms
    calclInitializePlatforms ( calclManager );

    // Initialize the devices
    calclInitializeDevices ( calclManager );

    // Uncomment if platforms and devices are unknown
    //calclGetPlatformsAndDeviceFromStandardInput();

    // get the first device on the first platform
    // this call is unnecessary if calclGetPlatformsAndDeviceFromStandardInput() is used
    CALCLdevice device = calclGetDevice ( calclManager , 0, 0 );

    // create a context
    CALCLcontext calclContext = calclCreateContext ( &device , 1 );

    // ...
  }
\end{lstlisting}

The \verb'calCL2D.h' header file, needed to define OpenCAL-CL 2D CA,
is included at line 1. Line 6 declares a pointer to the above cited
\verb'CALOpenCL' strucure, and initializes it through the
\verb'calclCreateCALOpenCL()' utility function. This object,
\verb'calclManager', is used as parameter for the
\verb'calclInitializePlatforms()' function at line 9, which fills the
object with the platforms available on the machine. Line 12 calls the
\verb'calclInitializeDevices()' function, that initializes the
available devices, while line 19 selects one of them for kernel
execution. Specifically, an object of type \verb'CALCLdevice' is
declared ad initialized by the function \verb'calclGetDevice()'. This
latter takes as first parameter a pointer to a \verb'CALOpenCL'
object, while the second and third parameters are used to select
platform and device, respectively. Since both platforms and devices
are identified by a 0-based index\footnote{In OpenCAL-CL platforms and
  devices are stored in a matrix where rows represent platforms and
  columns devices. Thus, to choose which platform and device to use
  for the computation, it is necessary to specify their indexes within
  the matrix. For example, at lines 15, we chose the platform number 0
  and the device number 0. If we have a system with 3 NVIDIA GPUs and
  3 AMD GPUs, the library will have a $2 \times 3$ size matrix, where
  2 are the vendors (i.e., the platforms NVIDIA and AMD) and 3 are the
  GPUs for each platforms. If we want to run the program using the
  third AMD GPU, we can specify 1 and 2 as indices.}, statement at
line 15 selects the first device belonging to the first platform
(e.g. a GTX 980 belonging to the NVIDIA CUDA platform). If system's
platforms and devices are unknown, the
\verb'calclGetPlatformsAndDeviceFromStandardInput()' function can be
used alternatively to \verb'calclGetDevice()'. It prints all the
available platforms and devices and permits for their interactive
selection. Eventually, line 22 creates a OpenCL context, based on the
device previously selected. At this porpose, an object of type
\verb'CALCLcontext' is declared and defined by means of the
\verb'calclCreateContext()' function.

\subsection{OpenCAL-CL toolkit Definition and Kernels Management}

After the compliant device has been chosen and elementary processes
implemented as kernels, these latter can automatically be read and
compiled through the \verb'calclLoadProgram2D()' function
(cf. Listing \ref{lst:calclLoadProgram}). It takes both the context
and device, and also the paths of user defined kernels and
corresponding headers as parameters, and returns an OpenCL
program\footnote{\texttt{CALCLprogram} redefines the
\texttt{cl\_program} OpenCL type.}.

\begin{lstlisting}[float,floatplacement=H, label=lst:calclLoadProgram, caption={The calclLoadProgramLib function. It loads and compiles kernels by returning an OpenCL program.}, numbers=none]
  CALCLprogram calclLoadProgram2D (
    CALCLcontext context ,
    CALCLdevice device ,
    char * path_user_kernel ,
    char * path_user_include
  )
\end{lstlisting}

Once compiled and grouped into an OpenCL program, kernels can be
extracted in order to be attached to a command queue for
execution. Specifically, the \verb'calclGetKernelFromProgram()'
function extracts a kernel from an OpenCL program, taking a pointer to
the program and the kernel name (cf. Listing
\ref{lst:calclGetKernelFromProgram}).

\begin{lstlisting}[float,floatplacement=H, label=lst:calclGetKernelFromProgram, caption={The calclGetKernelFromProgram kernel extraction function}., numbers=none]
  CALCLkernel calclGetKernelFromProgram (
    CALCLprogram * program,
    char * kernelName 
  )
\end{lstlisting}

In order to equeue the extracted kernels, OpenCAL-CL make use of an
instance of the \verb'CALCLToolkit2D' data structure\footnote{Instead
  of explicitly adopting an OpenCL command queue.}, which can be
created by means of the \verb'calclCreateToolkit2D()' function
(cf. Listing \ref{lst:calclCreateToolkit2D}). The first parameter is a
pointer to a \verb'CALModel2D', defined host side as in the case of the
serial implementation of OpenCAL (cf. Chapter \ref{ch:opencal}). The
second one is an OpenCL context, as well as the third and fourth
parameters are an OpenCL program and compliant device, respectively.

\begin{lstlisting}[float,floatplacement=H, label=lst:calclCreateToolkit2D, caption=The calclCreateToolkit2D data structure., numbers=none]
  CALCLToolkit2D * calclCreateToolkit2D(
                   struct CALModel2D * model,
                   CALCLcontext context,
                   CALCLprogram program,
                   CALCLdevice device
  )
\end{lstlisting}

The function \verb'calclAddElementaryProcessKernel2D' adds a new
kernel to the execution queue
(cf. Listing \ref{lst:calclAddElementaryProcessKernel2D}).

\begin{lstlisting}[float,floatplacement=H, label=lst:calclAddElementaryProcessKernel2D, caption=The calclCreateToolkit2D function., numbers=none]
  void calclAddElementaryProcessKernel2D(
               CALCLToolkit2D * toolkit2d,
               struct CALModel2D *model,
               CALCLkernel * elemProcKernel
  );
\end{lstlisting}



Kernel parameters...




\subsection{Simulation execution on the compliant device}

The \verb'calclRun()' function (cf. Listing \ref{lst:calclRun2D}) runs the CA simulation by executing
all the defined kernels on the selected compliant device.

\begin{lstlisting}[float,floatplacement=H, label=lst:calclRun2D, caption=The calclRun2D function., numbers=none]
  void calclRun2D(CALCLToolkit2D* toolkit2d,
                  struct CALModel2D * model,
                  unsigned int initialStep,
                  unsigned maxStep
  );
\end{lstlisting}


\section{OpenCAL-CL Kernel Programming}

Let us condider the OpenCAL-CL kernel example in Listing (cf. Listing
\ref{lst:OpenCAL-CL-kernel}. To define an OpenCAL-CL kernel, the
\verb'cal2D.h' header must be included (line 1). Accordingly to OpenCL, each
kernel definition must start with the \verb'__kernel'
keyword. However, differently to OpenCL, each OpenCAL-CL kernel must
have (at least) an implicit parameter,
i.e. \verb'__CALCL_MODEL_2D'. It is macro-like C object, and is used
to implicitly let the kernel to know details about the CA model,
e.g. the defined neighborhood. Moreover, the \verb'initThreads2D()'
function must be the first to be called into the kernel as it prevents
the execution of a number of threads exceeding the CA
dimension. Eventually, function calls that in OpenCAL were requiring a
pointer to a CA model, here take the \verb'MODEL_2D' macro-like C
object to its place (cf. Listing \ref{lst:OpenCAL-CL-kernel}, line
17).


In order to program kernels in OpenCAL, the user needs to include some
header files. Specifically, \verb'cal2D.h' or \verb'cal3D.h' permit
to use some simple functions to interact with the data structures
belonging to the model. To create a kernel function in OpenCL, the user
must place the keyword \verb'__kernel' before the returning the type
of the function. In OpenCAL-CL every time a kernel function is defined, the
keyword \verb'MODEL_DEFINITION2D' must be specified as first parameter
and the function \verb'initThreads2D()' called as first
instruction.\\ The code below shows how to declare a new kernel.

\begin{lstlisting}[float,floatplacement=H, label=lst:OpenCAL-CL-kernel, caption=Example of OpenCAL-CL kernel.] 
  #include <cal2D.h>

  // Define handles to CA substates
  //...
  #define Z 4
  #define H 5

  //...
  
  __kernel void kernel(__CALCL_MODEL_2D)
  {
    // Prevent the execution of more threads than the CA dimension
    initThreads2D();

    //...

    // Get the cell coordinates back
    int i = getRow();
    int j = getCol();

    //...

    // Set a new value for the substate
    // whose handle is defined by H.
    // Please, note the usage of the
    // MODEL_2D macro-like object
    calSet2Dr(MODEL_2D, H, i, j, h_next);
    
    //...
  }
\end{lstlisting}

When the user implements an elementary process - by defining
the corresponding kernel function - she/he can rely on a set of OpenCAL functions
that allow to get the substates values of both the central and the
neighbouring cells, and to update the substates values of the central
cell. Every time the user wants to use this function, the keyword \verb'MODEL2D' must be passed
as first parameter. For instance, if we
want to retrieve the value of a specific cell we need to use the function
\verb'calGet2Dr'.

\begin{lstlisting}[numbers=none] 
	double a = calGet2Dr(MODEL2D, 0, i, j);
\end{lstlisting}

The function returns the value of the cell (i, j) of the substate
0. Since inside OpenCAL-CL one can use all OpenCL advanced features, all
memory levels such as global memory, local memory, private memory
can be exploited. In order to use these memory
levels, variables must be declared using this specific syntax
\verb'__global', \verb'__local', \verb'__private',respectively.

\section{Conway's Game of Life with OpenCAL-CL}
 
As already reported in \ref{sec:cal_life}, to introduce how to develop
a CA model with OpenCAL-CL we can start by implementing Conway’s Game
of Life and specifically its host application part, which is shown in
Listing \ref{lst:calcl_life}. In order to use OpenCAL-CL, some header
files are included (lines 3-8) and, in particular, the OpenCAL library
and the OpenCAL-CL library. The OpenCAL library inclusion is necessary
to define the CA object (line 46) and the related substates (line
49). The \verb'cal2DIO.h' header file (line 4) provides some basic
input/output functions for reading/writing substates from/to file. To
run the application with OpenCAL-CL, all the necessary objects have to
be declared (line 27-31): specifically, the \verb'CALOpenCL' structure
(line 27), the \verb'CALCLcontext', the \verb'CALCLdevice', the
\verb'CALCLprogram' and the \verb'CALCLToolkit2D'. To create and
initialize these variables we need to call the function
\verb'calclCreateCALOpenCL' that creates the CALOpenCL structure, the
functions \verb|calclInitializePlatforms| and
\verb|calclInitializeDevices| that initialize all the platforms and
devices on the available machine and the \verb'calclGetDevice()'
function, which will return the device where elementary process are
computed by choosing the \verb'platformNum' and \verb'deviceNum'
integers(line 24-25). Moreover, two important functions are here
considered: \verb'calclcreateContext' and
\verb'calclLoadProgram2D'. The first returns the context
(see \ref{sec:opencalclstructure}), while the second builds all kernels inside
the path specified by \verb'kernelSrc'(line 15) including the files
specified by \verb'kernelInc'(line 16), and returns a program
containing all the compiled kernels.

The definition and declaration of the model (line 46) has the same code
that we discussed in \ref{sec:cal_life}, and includes all the information
to create the model, to create and initialize substates (line 49-52) and 
to set a initial configuration (line 55-59).

\lstinputlisting[label=lst:calcl_life, caption=An OpenCAL-CL
  implementation of the Conway's game of
  Life.]{../opencal/OpenCAL-CL/examples/calcl_life/source/life.c}
	
Although the OpenCAL-CL library uses the same functions of the OpenCAL
library to create the model and the substates, the execution of the
elementary processes is quite different. As known, our elementary
processes are implemented on GPU side through kernels, so we need to
manage the transfer of memory between host and device sides and to
decide which and when run the kernels. In a classical OpenCL
application, it's not trivial to handle all these issues. For this
reason, in OpenCAL-CL we decided to introduce an intermediate object
(\verb'CALCLToolkit') that hides to the user the memory management and
handles the compiled chosen kernels. The user must only initialize the
\verb'CALCLToolkit' structure(line 62) and choose which kernel he/she
wants to execute by the function \verb'calclGetKernelFromProgram'
specifying the program and kernel names. Once kernels are chosen to be
executed, the user must only call the function
\verb'calclAddElementaryProcessKernel2D' (line 71) that adds the
specific kernel elementary process inside the \verb'CALCLToolkit'
structure. Finally, to run the simulation, the user must call the
function \verb'calclRun2D' specifying the initial and final step.

Below is reported the device-side code of Conway's Game of Life.  In
this application, we have only one elementary process, defined as a
kernel called \verb'life_transition_function'. The OpenCAL-CL library
will launch exactly a number of threads equal to the entire cellular
space, structured like a matrix. In this way, every cell can perform
in parallel its own computation. To access to the indexes of the cell
the user must call the function \verb'getRow' and \verb'getCol'
line(14-15). Furthermore, the user can use the function
\verb'get_columns' and \verb'get_rows' (line 17-18) to retrieve the
dimensions of the cellular space.  In the specific case of the Game of
Life, we used the \verb'calGet2Di' function to get the central cell’s
value of the substate Q (remember that the central cell is identified
by the coordinates (i, j)), the \verb'calGetX2Di' function to retrieve
the value of the n-th neighbour’s substate Q, and the \verb'calSet2Di'
function to update the value of the substate Q for the central cell.

\lstinputlisting[label=lst:calcl_life, caption=An OpenCAL-CL kernel
  to implement the Conway's game of Life elementary
  process.]{../opencal/OpenCAL-CL/examples/calcl_life/kernel/source/life.cl}


\section{Combining OpenCAL-OMP and OpenCAL-GL and  Global Functions}

As for OpenCAL, it is possible to exploit OpenCAL-GL to have a simple
visualization system by adding few lines of code to your
application. Combining OpenCAL-CL and OpenCAL-GL does not differ from
what we have done in Section \ref{sec:combining_gl} for OpenCAL and
OpenCAL-GL. Therefore, please refer to this section for major
details.

Similarly, you can use the same global reduction functions
described in Section \ref{sec:redution} also in OpenCAL-CL.  Please
refer to that section for further details.
