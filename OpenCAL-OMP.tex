\chapter{OpenCAL OpenMP version}\label{ch:opencal-omp}

Nowadays, parallel computing is the most effective solution to
overcome temporal limits of sequential computation.  With the name
OpenCAL-OMP, we identify the OpenMP implementation of the software
library, that can run on all cores for your CPU. If you are lucky and
have a shared memory multiptocessor system, OpenCAL-OMP can also
exploit all the cores of all your CPUs.

Similarly to the serial version, OpenCAL-OMP allows for some
\emph{unsafe operations}, which can significantly speed up your
application. However, when you use OpenCAL-OMP in \emph{unsafe mode}
you must give the utmost attention to avoid\textsl{ race condition}
issues. For instance, when many threads perform concurrent operations
on the same memory locations and such operations are made by more than
one atomic machine instruction, it can happen that they can
interleave, giving rise to wrong (i.e., non consistent)
results. Furthermore, even in the case of atomic operations, the logic
order of execution could not be respected. Thus, for instance, a
read-write logic sequence of atomic operations can actually become a
write-read (wrong) sequence due to the fact that the thread performing
the write operation is executed first.

In the following sections we will introduce OpenCAL-OMP by examples,
highlighting source code the differences with respect to the serial
implementations shown in Chapter \ref{ch:opencal}. In the first part of
the Chapter, we will deal with the OpenCAL's \emph{safe mode}, while in
the last one, we will discuss unsafe operations.

\section{Conway's Game of Life in OpenCAL-OMP}

In Section \ref{sec:cal_life}, we described Conway's Game of Life and
shown a possible implementation using the \verb'OpenCAL' serial
library. Here, we present a \verb'OpenCAL-OMP' implementation of the
same cellular automaton (Listing \ref{lst:calomp_life}), by discussing
the differences with respect its serial implementation (Listing
\ref{lst:cal_life}).

\lstinputlisting[float,floatplacement=H, label=lst:calomp_life, caption=An OpenCAL-OMP implementation of the Conway's game of Life.]{../opencal/OpenCAL-OMP/examples/calomp_life/source/life.c}

As you can see, the OpenMP-based implementation of Life, which uses
only safe operations, is almost identical to the serial one thanks to
the seamless parallelization adopted by the library.  The only
differences can be found at lines 3-5 where, instead of including the
OpenCAL header files, you can find the OpenCAL-OMP headers. All the
remaining source code is unchanged. In practice, if you only use
OpenCAL-OMP in safe mode, besides including the proper OpenCAL-OMP
header files instead of the OpenCAL ones, minimal changes are required
to the serial code.

\section{OpenCAL-OMP statement convention and Custom Neighbourhoods}

The OpenCAL-OMP statements' prefix does not change with respect to the
OpenCAL's one (i.e. \verb'cal' for the functions, \verb'CAL' for the
data types, and \verb'CAL_' for the constants). Please, refer to
Section \ref{sec:Conventions} for further details.

Similarly to OpenCAL, OpenCAL-OMP allows to define custom
neighbourhoods. Since there are no differences whith respect to
OpenCAL, please refer to Section \ref{sec:CustomNeiughbourhoods} for
further details.

\section{SciddicaT}

As for the case of Conway's Game of Life, even the OpenCAL-OMP
implementation of the SciddicaT cellular automaton, shown in Lsting
\ref{lst:calomp_sciddicaT}, does not significantly differ from the
serial implementation that you can find in the Section
\ref{sec:sciddicaT}, Listing \ref{lst:cal_sciddicaT}. As before, the
only differences regard the included headers (lines 3-5). Even in this
case, as for the Life cellular automaton, due to the fact we used only
OpenCAL-OMP safe operations, mimimal code change is required, besides
including the proper OpenCAL-OMP header files instead of the OpenCAL
ones.

\lstinputlisting[label=lst:calomp_sciddicaT, caption=An OpenCAL-OMP implementation of the SciddicaT debris flows simulation model.]{../opencal/OpenCAL-OMP/examples/calomp_sciddicaT/source/sciddicaT.c}

\section{SciddicaT with active cells optimization}
Here we present an OpenCAL-OMP implemenation of SciddicaT, which takes
advantage of the built-in OpenCAL active cells optimization feature. You can
find the complete source code in Listing
\ref{lst:calomp_Sciddicat-activecells}, while the corresponding serial
implementation can be found in Section
\ref{sec:sciddicaT_active}, Listing
\ref{lst:cal_Sciddicat-activecells}.

\lstinputlisting[label=lst:calomp_Sciddicat-activecells, caption=An OpenCAL-OMP implementation of the SciddicaT debris flows simulation model with the active cells optimization.]{../opencal/OpenCAL-OMP/examples/calomp_sciddicaT-activecells/source/sciddicaT.c}

With respect to the Sciddica implementation shown in Listing
\ref{lst:calomp_sciddicaT}, which is exclusively based on safe
OpenCAL-OMP operations, the active cells management as implemented
here requires an unsafe operations. Such unsafe operations are
performed by means of the \verb'calAddActiveCellX2D()' function (line
87), which adds a cell belonging to the neighbourhood to the set $A$
of active cells. As evident, such an operation is considered unsafe
because it can give rise to race condition. In fact, if more threads
try to add the same cell to the set $A$ at the same time, being this a
non-atomic operation, threads' operations can interleave and the
outcome be wrong. In order to avoid this possible error, OpenCAL-OMP
is able to \emph{lock} the memory locations involved in the operations
so that each thread can entirely perform its own task without the risk
that other threads interfere. In order to do this, it is sufficient to
place OpenCAL-OMP in \emph{unsafe} state by calling the
\verb'calSetUnsafe2D()', as done at line 163. No other modifications
to the serial source code are required.

\section{SciddicaT as eXtended CA}
Here we present an OpenCAL-OMP implementation of SciddicaT, which takes
advantage of the built-in unsafe operations. They belong to the
eXtended CA definition and allow for further computational
optimizations. You can find the complete source code of SciddicaT
implemented as an eXtended CA in Listing
\ref{lst:calomp_SciddicaT-unsafe}, while the corresponding serial
implementation can be found in Section \ref{sec:sciddicaT_extended},
Listing \ref{lst:cal_sciddicaT-unsafe}.

\lstinputlisting[label=lst:calomp_SciddicaT-unsafe, caption=An OpenCAL-OMP implementation of the SciddicaT debris flows eXtended CA simulation model with unsafe optimization.]{../opencal/OpenCAL-OMP/examples/calomp_sciddicaT-unsafe/source/sciddicaT.c}

First of all - from a XCA modeling point of view - note that only the
topographic altitude and the debris thickness are now considered as
model's substates (lines 25-28, 147-148), as the four outflows
substates are no longer needed. Moreover, the number of elementary
process now considered is two (lines 143-144), instead of three for
the previous versions of SciddicaT.

The call to the \verb'calSetUnsafe2D()' function (line 139) places
OpenCAL-OMP in unsafe mode, allowing to lock memory locations
(i.e. cells) that can be simultaneously accessed by more threads. In
order properly exploit the OpenCAL-OMP's built in lock feature, you
have to use specific functions, which are provided by the
\verb'OpenCAL-OMP/cal2DUnsafe.h' header file (line 6). In the specific
case, besides the already discussed \verb'calAddActiveCellX2D()'
function, the \verb'calAddNext2Dr()' and \verb'calAddNextX2Dr()'
functions are employed (lines 88-89), in place of the combination of
get-set operations, as done in the corresponding serial implementation
(Listing \ref{lst:cal_sciddicaT-unsafe}, lines 84-85). In fact,
consider the source code snippet in Listing \ref{lst:get-set} (checked
out by Listing \ref{lst:cal_sciddicaT-unsafe}). As you can see, for
each not-eliminated cell, the algorithm computes a flow, $f$ (line 5)
and then subtracts it from the central cell (line 6), adding it to the
corresponding neighbour (line 7), in order to accomplish mass
balance. In both cases (flow subtraction and adding), a flavor of
\verb'calGet' function is called to read the current value of the
$Q_h$ substate from the next working plane. Subsequently, a flavor of
the \verb'calSet' function is used to update the previously read
value. When a single thread is used to perform such operations, no
race conditions can obviously occur. At the contrary, even in the case
of two concurrent threads, different undesirable situations can take
place, which give rise to a race condition and therefore to a wrong
result. For instance, let's suppose both threads read the value first,
and then write their updated values; in this case, the resulting value
will correspond to the one written by the thread that writes the value
for last, and the contribution of the other thread will be lost.

\begin{lstlisting}[float,floatplacement=H, label=lst:get-set, caption=Example of non atomic operation made of a combination of get-set calls.]
  // <snip>
  for (n=1; n<sciddicaT->sizeof_X; n++)
  if (!eliminated_cells[n])
  {
    f = (average-u[n])*P.r;
    calSet2Dr (sciddicaT,Q.h,i,j,  calGetNext2Dr (sciddicaT,Q.h,i,j)  -f);
    calSetX2Dr(sciddicaT,Q.h,i,j,n,calGetNextX2Dr(sciddicaT,Q.h,i,j,n)+f);
    // <snip>
  }
  // <snip>
\end{lstlisting}  

In order to avoid such kind of problems when dealing with more
threads, the above mentioned \verb'calAddNext2Dr()' and
\verb'calAddNextX2Dr()' functions lock the cell under consideration
and then perform the get-set operations without the risk other threads
can interfere. In this way, no race conditions can be
triggered. Obviously, there is a side-effect in terms of computational
performance. In fact, as expected, locks can slow down threads
execution and therefore the entire simulation.


\section{SciddicaT with explicit simulation loop}

As for the serial version, also for the OpenMP based release of
OpenCAL it is further possible to improve computational performance of
SciddicaT by avoiding unnecessary substates updating.

As already reported, the \verb'calRun2D()' function used so far to
run the simulation loop updates all the defined substates at the end
of each elementary process. However, in the specific case of the
SciddicaT XCA model, no substates updating should be executed after
the application of the second elementary process, as this just removes
inactive cells from the set $A$.

A new OpenCAL implementation of SciddicaT is presented in Listing
\ref{lst:calomp_sciddicaT-explicit}. It is based on an explicit global
transition function, defined by means of
\verb'calRunAddGlobalTransitionFunc2D()'. It registers a callback
function within which you can both reorder the sequence of elementary
processes to be applied in the generic computational step, and also
select which substates have to be updated after the execution of the
different elementary processes. The SciddicaT implementation here
presented in Listing \ref{lst:calomp_sciddicaT-explicit} also
makes explicit the simulation loop and defines a stopping criterion for
the simulation termination.


\lstinputlisting[label=lst:calomp_sciddicaT-explicit, caption=An
  OpenCAL-OMP implementation of the SciddicaT XCA debris flows
  simulation model with explicit simulation
  loop.]{../opencal/OpenCAL-OMP/examples/calomp_sciddicaT-unsafe-explicit/source/sciddicaT.c}

\section{SciddicaT computational performance}

Table \ref{tab:speedup} resumes computational performance of all the
above illustrated SciddicaT implementations as implemented in
OpenCAL-OMP. The considered case of study is the simulation of the
Tessina landslide shown in Figure \ref{fig:sciddicaT}, which required
a total of 4000 computational steps. The adopted CPU is a Intel Core
i7-4702HQ @ 2.20GHz 4 cores (8 threads) processor, already considered
for the performance evaluation of the corresponding serial SciddicaT
implementations described in Chapter \ref{ch:opencal}. Results are
provided both in terms of elapsed time and speed up with respect to
the corresponding serial version. Elapsed times of the serial
simulations are also reported.

\begin{table}
  \centering
  \footnotesize
  \begin{tabular}{l|c|c|c|c|c|c}
    \hline
    T version & Serial [s] & 1thr & 2thr & 4thr & 6thr & 8thr\\
    \hline
    \hline
    naive         & 240s & 0.82 (293s) & 1.22 (196s) & 1.53 (157s) & 1.64 (146s) & 1.6 (150s)\\
    active cells  & 23s  & 0.77 (30s)  & 1.36 (17s)  & 1.77 (13s)  & 2.09 (11s)  & 2.3 (10s)\\
    eXtended CA   & 13s  & 0.77 (17s)  & 1.86 (7s)   & 2.6  (5s)   & 2.17  (6s)  & 2.6 (5s)\\
    explicit loop & 12s  & 0.75 (16s)  & 1.2  (10s)  & 2.4  (5s)   & 2.4  (5s)   & 3.0 (4s)\\
    \hline
  \end{tabular}
  \caption{Speedup of the four different
    implementations of the SciddicaS3hex debris flows model accelerated by OpenMP.}
  \label{tab:speedup}
\end{table}

As you can see, results are quite good. In particular, the better
results in terms of speed up were obtained for the fully optimized
SciddicaT implementation (with the explicit substate updating
feature), which runs 3 time faster than the corresponding serial
version when executed over 8 threads. Nevertheless, consider that the
SciddicaT simulation model here adopted is quite simple and better
performance in terms of speed up can certainly be obtained for CA
models with more complex transition functions and extended
computational domains.

Eventually, please note how progressive optimizations can considerably
reduce the overall execution time. In fact, if for the naive (i.e., non
optimized at all) serial implementation the elapsed time was 240s, for
the fully optimized parallel version the simulation lasted only 3
seconds, corresponding to a speed up value of 80, i.e. the fully
optimized parallel version runs 80 times faster than the serial naive
implementation.

%% \begin{table}
%%   \centering
%%   \begin{tabular}{l|c|c|c|c|c|c}
%%     \hline
%%     S3-hex version & Serial [s] & 1thr & 2thr & 4thr & 6thr & 8thr\\
%%     \hline
%%     \hline
%%     naive         & 1030s & 0.52 (1982s) & 0.9 (1142s) & 1.03 (998s) & 1.13 (913s) & 1.3  (781s)\\
%%     active cells  & 55s   & 0.86 (64s)   & 1.57 (35s)  & 2.75 (20s)  & 2.5  (22s)  & 3.06 (18s)\\
%%     eXtended      & 27s   & 0.87 (31s)   & 1.42 (19s)  & 2.7  (10s)  & 2.46 (11s)  & 3.38 (8s)\\
%%     explicit loop & 16s   & 0.8  (20s)   & 1.33 (12s)  & 2.67 (6s)  & 2.29  (7s)   & 3.2  (5s)\\
%%     \hline
%%   \end{tabular}
%%   \caption{Speedup of the four different
%%     implementations of the SciddicaS3hex debris flows model accelerated by OpenMP.}
%%   \label{tab:speedup}
%% \end{table} 

%% \begin{table}
%%   \centering
%%   \begin{tabular}{l|c|c|c}
%%     \hline
%%     mbusu version & Serial [s] & OpenMP 6th & OpenCL (Quadro FX 1100M)\\
%%     \hline
%%     \hline
%%     naive         & 7796s & 3.57 (2185s) & 3.52 (2213s)\\
%%     \hline
%%   \end{tabular}
%%   \caption{mbusu Speedup.}
%%   \label{tab:speedup}
%% \end{table} 

%% \begin{table}
%%   \centering
%%   \begin{tabular}{l|c|c}
%%     \hline
%%     Threads & Elapsed time [s] & Speedup\\
%%     \hline
%%     \hline
%%     1       & 7308             & 1     \\
%%     2       &                  &       \\
%%     4       &                  &       \\
%%     6       & 2185             & 3.34  \\
%%     8       &                  &       \\
%%     \hline
%%   \end{tabular}
%%   \caption{mbusu Speedup.}
%%   \label{tab:speedup}
%% \end{table} 


\section{A three-dimensional example}
In Section \ref{sec:mod2}, we described the \emph{mod2} 3D CA and
shown a possible implementation using the \verb'OpenCAL' serial
library. Here, we briefly present a \verb'OpenCAL-OMP' implementation
of the same cellular automaton (Listing \ref{lst:calomp_life}), by
discussing the differences with respect the corresponding serial
implementation (Listing \ref{lst:cal_life}).

\lstinputlisting[float,floatplacement=H, label=lst:calomp_mod2,
  caption=An OpenCAL-OMP implementation of the mod2
  CA.]{../opencal/OpenCAL-OMP/examples/calomp_mod2CA3D/source/mod2CA3D.c}

As you can see, the OpenMP-based implementation, which uses only safe
operations, is almost identical to the serial one. As for the case of
the Game of Life CA, the only differences can be found at lines 3-5
where, instead of including the OpenCAL header files, we included the
OpenCAL-OMP headers. All the remaining source code is unchanged.

\section{Combining OpenCAL-OMP and OpenCAL-GL and Global Functions}

As for OpenCAL, it is possible to exploit OpenCAL-GL to have a simple
visualization system by adding few lines of code to your
application. Combining OpenCAL-OMP and OpenCAL-GL does not differ from
what we have done in Section \ref{sec:combining_gl} for OpenCAL and
OpenCAL-GL. Therefore, please refer to that section for major details.

Similarly, you can also use the same global reduction functions
described in Section \ref{sec:redution} in OpenCAL-OMP. Plese refer to
that section for further details.
